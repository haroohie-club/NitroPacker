using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;

namespace HaroohieClub.NitroPacker.Patcher;

/// <summary>
/// Enum representing the different build system types supported by the NitroPacker patcher
/// </summary>
public enum BuildType
{
    /// <summary>
    /// The make-based build system using devkitARM and make
    /// </summary>
    Make,
    /// <summary>
    /// The Docker-based build system using Docker (and WSL on Windows)
    /// </summary>
    Docker,
    /// <summary>
    /// The ninja-based build system using ninja and clang
    /// </summary>
    NinjaClang,
    /// <summary>
    /// Indicates no build system was specified (will error)
    /// </summary>
    NotSpecified,
}

internal static class Utility
{
    public static int IndexOfSequence<T>(this IEnumerable<T> items, IEnumerable<T> search)
    {
        IEnumerable<T> searchArray = search as T[] ?? search.ToArray();
        int searchLength = searchArray.Count();
        IEnumerable<T> itemsArray = items as T[] ?? items.ToArray();
        int lastIndex = itemsArray.Count() - searchLength;
        for (int i = 0; i < lastIndex; i++)
        {
            if (itemsArray.Skip(i).Take(searchLength).SequenceEqual(searchArray))
            {
                return i;
            }
        }
        return -1;
    }
    
    public static void GenerateNinjaBuildFile(string sourceDir, uint codeaddr, string llvmPath)
    {
        string exeExt = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : string.Empty;
        StringBuilder sb = new();
        sb.AppendLine("# File generated by NitroPacker");
        sb.AppendLine();
        
        sb.AppendLine($"LLVM             = {llvmPath}/bin/");
        sb.AppendLine($"CLANG            = ${{LLVM}}clang{exeExt}");
        sb.AppendLine($"LLD              = ${{LLVM}}lld{exeExt}");
        sb.AppendLine($"OBJCOPY          = ${{LLVM}}llvm-objcopy{exeExt}");
        sb.AppendLine();
        
        sb.AppendLine("rule makedir");
        sb.AppendLine("  command = mkdir $out");
        sb.AppendLine();
        
        sb.AppendLine("rule cc");
        sb.AppendLine("  command = ${CLANG} -target armv5-none-eabi -g -O3 -march=armv5te -mtune=arm946e-s -nodefaultlibs -c -o $out $in");
        sb.AppendLine();

        sb.AppendLine("ld");
        sb.AppendLine("  command = ${LLD} -T ./linker.x -T ./symbols.x -Ttext ${codeaddr} -g -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule objcopy");
        sb.AppendLine("  command = ${OBJCOPY} -O binary $in $out");
        sb.AppendLine();

        sb.AppendLine("build build: makedir");
        sb.AppendLine();

        foreach (string file in Directory.GetFiles(sourceDir))
        {
            if (Path.GetExtension(file).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                Path.GetExtension(file).Equals(".s", StringComparison.OrdinalIgnoreCase))
            {
                sb.AppendLine($"build build/{Path.GetFileName(file)}.o: cc {sourceDir.Replace('\\', '/')}/{Path.GetFileName(file)} || build");
                sb.AppendLine();
            }
        }
    }
}