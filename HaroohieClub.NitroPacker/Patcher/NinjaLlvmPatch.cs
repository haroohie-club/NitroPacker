using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using HaroohieClub.NitroPacker.Patcher.Nitro;

namespace HaroohieClub.NitroPacker.Patcher;

/// <summary>
/// Static class for handling ASM patching via ninja/LLVM
/// </summary>
public static class NinjaLlvmPatch
{
    /// <summary>
    /// Patches ARM9 and overlays all at once using ninja and LLVM
    /// </summary>
    /// <param name="sourceDir">The path to the directory containing ASM hacks</param>
    /// <param name="arm9">The ARM9 binary to patch</param>
    /// <param name="overlayDir">The directory containing the game's overlay files to be patched</param>
    /// <param name="ninjaPath">The path to the ninja executable</param>
    /// <param name="llvmPath">The path to the LLVM root directory</param>
    /// <param name="romProjFile">The path to the ROM project file generated by NitroPacker's unpacking function</param>
    /// <param name="arenaLoOffset">The ArenaLo offset of the ROM (can be determined as described in the documentation)</param>
    /// <param name="symTableHelperPath">The path to the SymTableHelper executable (defaults to looking in the current directory)</param>
    /// <param name="outputDataReceived">A handler for standard output from ninja</param>
    /// <param name="errorDataReceived">A handler for standard error from ninja</param>
    public static void Patch(string sourceDir, ARM9 arm9, string overlayDir, string ninjaPath, string llvmPath,
        string romProjFile, uint arenaLoOffset, string symTableHelperPath = "", DataReceivedEventHandler outputDataReceived = null,
        DataReceivedEventHandler errorDataReceived = null)
    {
        uint arenaLo = arm9.ReadU32LE(arenaLoOffset);
        GenerateNinjaBuildFile(sourceDir, overlayDir, llvmPath, symTableHelperPath, romProjFile, arenaLo);
        RunNinja(ninjaPath, sourceDir, outputDataReceived, errorDataReceived);

        byte[] newArm9Code = File.ReadAllBytes(Path.Combine(sourceDir, "build", "newcode.bin"));
        ARM9AsmHack.PatchArm9(Path.Combine(sourceDir, "build"), arm9, arenaLoOffset, arenaLo, newArm9Code);
        
        // Perform the replacements for each of the replacement hacks we assembled
        if (Directory.Exists(Path.Combine(sourceDir, "build", "repl")))
        {
            foreach (string replFile in Directory.GetFiles(Path.Combine(sourceDir, "build", "repl"), "*.bin"))
            {
                byte[] replCode = File.ReadAllBytes(replFile);
                uint replaceAddress = uint.Parse(Path.GetFileNameWithoutExtension(replFile), NumberStyles.HexNumber);
                arm9.WriteBytes(replaceAddress, replCode);
            }
        }
    }

    private static bool RunNinja(string ninjaPath, string sourceDir, DataReceivedEventHandler outputDataReceived, DataReceivedEventHandler errorDataReceived)
    {
        Process ninjaProc = new()
        {
            StartInfo = new()
            {
                FileName = ninjaPath,
                WorkingDirectory = sourceDir,
                CreateNoWindow = true,
                UseShellExecute = false,
                RedirectStandardError = true,
                RedirectStandardOutput = true,
            },
        };
        ninjaProc.OutputDataReceived += outputDataReceived ?? ConsoleLogger;
        ninjaProc.ErrorDataReceived += errorDataReceived ?? ConsoleLogger;
        ninjaProc.Start();
        ninjaProc.BeginOutputReadLine();
        ninjaProc.BeginErrorReadLine();
        ninjaProc.WaitForExit();
        return ninjaProc.ExitCode == 0;

        static void ConsoleLogger(object sender, DataReceivedEventArgs e)
        {
            Console.WriteLine(e.Data);
        }
    }
    
    private static void GenerateNinjaBuildFile(string sourceDir, string overlayDir, string llvmPath, string symTableHelperPath, string romProjFile, uint arenaLo)
    {
        string exeExt = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : string.Empty;
        StringBuilder sb = new();
        sb.AppendLine("# File generated by NitroPacker");
        sb.AppendLine();
        
        sb.AppendLine($"LLVM             = {llvmPath}/bin/");
        sb.AppendLine($"CLANG            = ${{LLVM}}clang{exeExt}");
        sb.AppendLine($"LLD              = ${{LLVM}}ld.lld{exeExt}");
        sb.AppendLine($"OBJCOPY          = ${{LLVM}}llvm-objcopy{exeExt}");
        sb.AppendLine($"OBJDUMP          = ${{LLVM}}llvm-objdump{exeExt}");
        sb.AppendLine($"SYMTABLEHELPER   = {(string.IsNullOrEmpty(symTableHelperPath) ? 
            $"{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}/NitroPacker.SymTableHelper{exeExt}" :
            symTableHelperPath)}");
        sb.AppendLine();
        
        sb.AppendLine("rule makedir");
        sb.AppendLine("  command = mkdir $out");
        sb.AppendLine();
        
        sb.AppendLine("rule cc");
        sb.AppendLine("  command = ${CLANG} -target armv5-none-eabi -g -march=armv5te -mtune=arm946e-s -nodefaultlibs -c -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule ld");
        sb.AppendLine("  command = ${LLD} -T ./linker.x -T ./symbols.x -Ttext=0x${codeaddr} ${ldflags} -g -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule objcopy");
        sb.AppendLine("  command = ${OBJCOPY} -O binary $in $out");
        sb.AppendLine();

        sb.AppendLine("rule objdump");
        sb.AppendLine("  command = ${OBJDUMP} -t $in > $out");
        sb.AppendLine();

        sb.AppendLine("rule symtablehelper");
        sb.AppendLine("  command = ${SYMTABLEHELPER} $in $out");
        sb.AppendLine();

        sb.AppendLine("build build: makedir");
        sb.AppendLine();

        bool wroteMain = AppendNinjaBuildCommands(sb, sourceDir, sourceDir, arenaLo);
        
        NdsProjectFile proj = NdsProjectFile.Deserialize(romProjFile);
        foreach (string overlaySrcDir in Directory.GetDirectories(Path.Combine(sourceDir, "overlays")))
        {
            Overlay.Overlay overlay = new(Path.Combine(overlayDir, $"{Path.GetFileName(overlaySrcDir)}.bin"), romProjFile);
            AppendNinjaBuildCommands(sb, sourceDir, overlaySrcDir,
                proj.RomInfo.ARM9Ovt.First(o => o.Id == uint.Parse(overlay.Name[^4..])).RamAddress + (uint)overlay.Length,
                $"{overlay.Name}/", wroteMain ? " build/newcode.x" : "");
        }
        
        File.WriteAllText(Path.Combine(sourceDir, "build.ninja"), sb.ToString());
    }

    private static bool AppendNinjaBuildCommands(StringBuilder sb, string sourceRoot, string sourceDir, uint codeAddress, string overlay = "", string dependency = "")
    {
        bool wroteMain = false;
        
        string mainSource = Path.Combine(sourceDir, "source");
        if (Directory.Exists(mainSource))
        {
            List<string> objFiles = [];
            foreach (string file in Directory.GetFiles(mainSource).Where(f =>
                         Path.GetExtension(f).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                         Path.GetExtension(f).Equals(".s", StringComparison.OrdinalIgnoreCase)))
            {
                string objFile = $"build/{overlay}{Path.GetFileName(file)}.o";
                objFiles.Add(objFile);
                sb.AppendLine($"build {objFile}: cc {mainSource.Replace(sourceRoot, "").Replace('\\', '/')}/{Path.GetFileName(file)} || build{dependency}");
                sb.AppendLine();
            }

            sb.Append($"build build/{overlay}newcode.elf: ld ");
            sb.AppendJoin(' ', objFiles);
            sb.AppendLine($" || build{dependency}");
            sb.AppendLine($"  codeaddr = {codeAddress:X8}");
            sb.AppendLine($"  ldflags = {(string.IsNullOrEmpty(overlay) ? "" : "-Map build/newcode.x")}");
            sb.AppendLine();
        
            sb.AppendLine($"build build/{overlay}newcode.bin: objcopy build/{overlay}newcode.elf || build{dependency}");
            sb.AppendLine();
        
            sb.AppendLine($"build build/{overlay}newcode.sym: objdump build/{overlay}newcode.elf || build{dependency}");
            sb.AppendLine();

            sb.AppendLine($"build build/{overlay}newcode.x: symtablehelper build/{overlay}newcode.sym || build{dependency}");
            sb.AppendLine();

            wroteMain = true;
            dependency += $" build/{overlay}newcode.x";
        }

        string replSource = Path.Combine(sourceDir, "replSource");
        if (Directory.Exists(replSource))
        {
            foreach (string file in Directory.GetFiles(replSource).Where(f =>
                         Path.GetExtension(f).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                         Path.GetExtension(f).Equals(".s", StringComparison.OrdinalIgnoreCase)))
            {
                sb.AppendLine($"build build/{overlay}repl/{Path.GetFileName(file)}.o: cc {replSource.Replace(sourceRoot, "").Replace('\\', '/')}/{Path.GetFileName(file)} || build{dependency}");
                sb.AppendLine();

                sb.AppendLine($"build build/{overlay}repl/{Path.GetFileNameWithoutExtension(file)}.elf: ld build/{overlay}repl/{Path.GetFileName(file)}.o || build{dependency}");
                sb.AppendLine($"  codeaddr = {Path.GetFileNameWithoutExtension(file)}");
                sb.AppendLine($"  ldflags = {(string.IsNullOrEmpty(overlay) ? "" : "-Map build/newcode.x ")}-Map build/{overlay}newcode.x");
                sb.AppendLine();
            
                sb.AppendLine($"build build/{overlay}repl/{Path.GetFileNameWithoutExtension(file)}.bin: objcopy build/{overlay}repl/{Path.GetFileNameWithoutExtension(file)}.elf || build{dependency}");
                sb.AppendLine();
            }
        }
        
        return wroteMain;
    }
}