using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using HaroohieClub.NitroPacker.Patcher.Nitro;
using HaroohieClub.NitroPacker.Patcher.Overlay;

namespace HaroohieClub.NitroPacker.Patcher;

/// <summary>
/// Static class for handling ASM patching via ninja/LLVM
/// </summary>
public static class NinjaLlvmPatch
{
    /// <summary>
    /// Patches ARM9 and overlays all at once using ninja and LLVM
    /// </summary>
    /// <param name="sourceDir">The path to the directory containing ASM hacks</param>
    /// <param name="arm9">The ARM9 binary to patch</param>
    /// <param name="overlayDir">The directory containing the game's overlay files to be patched</param>
    /// <param name="ninjaPath">The path to the ninja executable</param>
    /// <param name="llvmPath">The path to the LLVM root directory</param>
    /// <param name="romProjFile">The path to the ROM project file generated by NitroPacker's unpacking function</param>
    /// <param name="arenaLoOffset">The ArenaLo offset of the ROM (can be determined as described in the documentation)</param>
    /// <param name="symTableHelperPath">The path to the SymTableHelper executable (defaults to looking in the current directory)</param>
    /// <param name="linkerFlags">Flags to pass directly to the linker (used for linking your own libraries)</param>
    /// <param name="outputDataReceived">A handler for standard output from ninja</param>
    /// <param name="errorDataReceived">A handler for standard error from ninja</param>
    /// <param name="newRomProjFile">(Optional) An output ROM project file (so the original is not overwritten)</param>
    public static Overlay.Overlay[] PatchAndReturnOverlays(string sourceDir, ARM9 arm9, string overlayDir, string ninjaPath, string llvmPath,
        string romProjFile, uint arenaLoOffset, string symTableHelperPath = "", string linkerFlags = "", DataReceivedEventHandler outputDataReceived = null,
        DataReceivedEventHandler errorDataReceived = null, string newRomProjFile = null)
    {
        uint arenaLo = arm9.ReadU32LE(arenaLoOffset);
        GenerateNinjaBuildFile(sourceDir, overlayDir, llvmPath, symTableHelperPath, romProjFile, arenaLo, linkerFlags);
        RunNinja(ninjaPath, sourceDir, outputDataReceived, errorDataReceived);

        string newArm9CodeFile = Path.Combine(sourceDir, "build", "newcode.bin");
        if (File.Exists(newArm9CodeFile))
        {
            byte[] newArm9Code = File.ReadAllBytes(newArm9CodeFile);
            ARM9AsmHack.PatchArm9(Path.Combine(sourceDir, "build"), arm9, arenaLoOffset, arenaLo, newArm9Code);
        }
        
        // Perform the replacements for each of the replacement hacks we assembled
        if (Directory.Exists(Path.Combine(sourceDir, "build", "repl")))
        {
            foreach (string replFile in Directory.GetFiles(Path.Combine(sourceDir, "build", "repl"), "*.bin"))
            {
                byte[] replCode = File.ReadAllBytes(replFile);
                uint replaceAddress = uint.Parse(Path.GetFileNameWithoutExtension(replFile), NumberStyles.HexNumber);
                arm9.WriteBytes(replaceAddress, replCode);
            }
        }

        List<Overlay.Overlay> overlays = [];
        string overlayPatchDir = Path.Combine(sourceDir, "overlays");
        foreach (Overlay.Overlay overlay in Directory.GetFiles(overlayDir)
                     .Select(o => new Overlay.Overlay(o, romProjFile))
                     .Where(o => Directory.GetDirectories(overlayPatchDir).Contains(Path.Combine(overlayPatchDir, o.Name))))
        {
            string newOverlayCodeFile = Path.Combine(sourceDir, "build", overlay.Name, "newcode.bin");
            if (File.Exists(newOverlayCodeFile))
            {
                byte[] newOverlayCode = File.ReadAllBytes(newOverlayCodeFile);
                string[] newSym = File.ReadAllLines(Path.Combine(sourceDir, "build", overlay.Name, "newcode.sym"));
                OverlayAsmHack.Patch(Path.Combine(sourceDir, "build", overlay.Name), overlay, newSym, newOverlayCode, newRomProjFile ?? romProjFile);
                overlays.Add(overlay);
            }
            
            // Perform the replacements for each of the replacement hacks we assembled
            if (Directory.Exists(Path.Combine(sourceDir, "build", overlay.Name, "repl")))
            {
                foreach (string replFile in Directory.GetFiles(Path.Combine(sourceDir, "build", overlay.Name, "repl"),
                             "*.bin"))
                {
                    byte[] replCode = File.ReadAllBytes(Path.Combine(sourceDir, "build", overlay.Name, "repl", $"{replFile}.bin"));
                    uint replaceAddress = uint.Parse(Path.GetFileNameWithoutExtension(replFile), NumberStyles.HexNumber);
                    overlay.Patch(replaceAddress, replCode);
                    if (!overlays.Contains(overlay))
                    {
                        overlays.Add(overlay);
                    }
                }
            }
        }

        if (Directory.Exists(Path.Combine(sourceDir, "build")))
        {
            Directory.Delete(Path.Combine(sourceDir, "build"), true);
        }
        File.Delete(Path.Combine(sourceDir, "build.ninja"));
        File.Delete(Path.Combine(sourceDir, ".ninja_log"));

        return [.. overlays];
    }

    private static bool RunNinja(string ninjaPath, string sourceDir, DataReceivedEventHandler outputDataReceived, DataReceivedEventHandler errorDataReceived)
    {
        Process ninjaProc = new()
        {
            StartInfo = new()
            {
                FileName = ninjaPath,
                WorkingDirectory = sourceDir,
                CreateNoWindow = true,
                UseShellExecute = false,
                RedirectStandardError = true,
                RedirectStandardOutput = true,
            },
        };
        ninjaProc.OutputDataReceived += outputDataReceived ?? ConsoleLogger;
        ninjaProc.ErrorDataReceived += errorDataReceived ?? ConsoleLogger;
        ninjaProc.Start();
        ninjaProc.BeginOutputReadLine();
        ninjaProc.BeginErrorReadLine();
        ninjaProc.WaitForExit();
        return ninjaProc.ExitCode == 0;

        static void ConsoleLogger(object sender, DataReceivedEventArgs e)
        {
            Console.WriteLine(e.Data);
        }
    }
    
    private static void GenerateNinjaBuildFile(string sourceDir, string overlayDir, string llvmPath, string symTableHelperPath, string romProjFile, uint arenaLo, string linkerFlags)
    {
        string exeExt = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : string.Empty;
        StringBuilder sb = new();
        sb.AppendLine("# File generated by NitroPacker");
        sb.AppendLine();

        sb.AppendLine($"LLVM             = {Utility.PathCombineAgnostic(llvmPath, "bin")}/");
        sb.AppendLine($"CLANG            = ${{LLVM}}clang{exeExt}");
        // LLD is installed in a separate cask on macOS w/ homebrew, so we need to account for that
        if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX) && llvmPath.Contains("opt/homebrew"))
        {
            sb.AppendLine( "LLD              = /opt/homebrew/opt/lld/bin/ld.lld");
        }
        else
        {
            sb.AppendLine($"LLD              = ${{LLVM}}ld.lld{exeExt}");
        }
        sb.AppendLine($"OBJCOPY          = ${{LLVM}}llvm-objcopy{exeExt}");
        sb.AppendLine($"OBJDUMP          = ${{LLVM}}llvm-objdump{exeExt}");
        sb.AppendLine($"SYMTABLEHELPER   = {(string.IsNullOrEmpty(symTableHelperPath) ? 
            Utility.PathCombineAgnostic(Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location), $"NitroPacker.SymTableHelper{exeExt}") :
            symTableHelperPath.Replace('\\', '/'))}");
        sb.AppendLine();
        
        sb.AppendLine("rule cc");
        sb.AppendLine("  command = ${CLANG} -target armv5-none-eabi -g -march=armv5te -mtune=arm946e-s -nodefaultlibs -c -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule ld");
        sb.AppendLine($"  command = ${{LLD}} -T ./linker.x -T ./symbols.x -Ttext=0x${{codeaddr}} ${{ldflags}} {linkerFlags ?? ""} -g -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule objcopy");
        sb.AppendLine("  command = ${OBJCOPY} -O binary $in $out");
        sb.AppendLine();

        sb.AppendLine("rule objdump");
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            sb.AppendLine("  command = cmd.exe /c \"\"${OBJDUMP}\" -t $in\" > $out");
        }
        else
        {
            sb.AppendLine("  command = ${OBJDUMP} -t $in > $out");
        }
        sb.AppendLine();

        sb.AppendLine("rule symtablehelper");
        sb.AppendLine("  command = ${SYMTABLEHELPER} $in $out");
        sb.AppendLine();

        sb.AppendLine("build build: phony");
        sb.AppendLine();

        bool wroteMain = AppendNinjaBuildCommands(sb, sourceDir, sourceDir, arenaLo);
        
        NdsProjectFile proj = NdsProjectFile.Deserialize(romProjFile);
        foreach (string overlaySrcDir in Directory.GetDirectories(Path.Combine(sourceDir, "overlays")))
        {
            Overlay.Overlay overlay = new(Path.Combine(overlayDir, $"{Path.GetFileName(overlaySrcDir)}.bin"), romProjFile);
            AppendNinjaBuildCommands(sb, sourceDir, overlaySrcDir,
                proj.RomInfo.ARM9Ovt.First(o => o.Id == uint.Parse(overlay.Name[^4..])).RamAddress + (uint)overlay.Length,
                $"{overlay.Name}/", wroteMain ? " build/newcode.x" : "");
        }
        
        File.WriteAllText(Path.Combine(sourceDir, "build.ninja"), sb.ToString());
    }

    private static bool AppendNinjaBuildCommands(StringBuilder sb, string sourceRoot, string sourceDir, uint codeAddress, string overlay = "", string dependency = "")
    {
        bool wroteMain = false;
        
        string mainSource = Path.Combine(sourceDir, "source");
        if (Directory.Exists(mainSource))
        {
            List<string> objFiles = [];
            foreach (string file in Directory.GetFiles(mainSource).Where(f =>
                         Path.GetExtension(f).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                         Path.GetExtension(f).Equals(".s", StringComparison.OrdinalIgnoreCase)))
            {
                string objFile = Utility.PathCombineAgnostic("build", overlay, $"{Path.GetFileName(file)}.o");
                objFiles.Add(objFile);
                sb.AppendLine($"build {objFile}: cc {Utility.PathRelativeAgnostic(sourceRoot, file)} || build{dependency}");
                sb.AppendLine();
            }

            if (objFiles.Count > 0)
            {
                sb.Append($"build build/{overlay}newcode.elf: ld ");
                sb.AppendJoin(' ', objFiles);
                sb.AppendLine($" || build{dependency}");
                sb.AppendLine($"  codeaddr = {codeAddress:X8}");
                sb.AppendLine($"  ldflags = {(string.IsNullOrEmpty(overlay) ? "" : "-Map build/newcode.x")}");
                sb.AppendLine();
        
                sb.AppendLine($"build build/{overlay}newcode.bin: objcopy build/{overlay}newcode.elf || build{dependency}");
                sb.AppendLine();
        
                sb.AppendLine($"build build/{overlay}newcode.sym: objdump build/{overlay}newcode.elf || build{dependency}");
                sb.AppendLine();

                sb.AppendLine($"build build/{overlay}newcode.x: symtablehelper build/{overlay}newcode.sym || build{dependency}");
                sb.AppendLine();

                wroteMain = true;
                dependency += $" build/{overlay}newcode.x";
            }
        }

        string replSource = Path.Combine(sourceDir, "replSource");
        if (Directory.Exists(replSource))
        {
            foreach (string file in Directory.GetFiles(replSource).Where(f =>
                         Path.GetExtension(f).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                         Path.GetExtension(f).Equals(".s", StringComparison.OrdinalIgnoreCase)))
            {
                sb.AppendLine($"build build/{overlay}repl/{Path.GetFileName(file)}.o: cc {Utility.PathRelativeAgnostic(sourceRoot, file)} || build{dependency}");
                sb.AppendLine();

                sb.AppendLine($"build build/{overlay}repl/{Path.GetFileNameWithoutExtension(file)}.elf: ld build/{overlay}repl/{Path.GetFileName(file)}.o || build{dependency}");
                sb.AppendLine($"  codeaddr = {Path.GetFileNameWithoutExtension(file)}");
                sb.AppendLine($"  ldflags = {(string.IsNullOrEmpty(overlay) ? "" : "-Map build/newcode.x ")}{(wroteMain ? $"-Map build/{overlay}newcode.x)" : string.Empty)}");
                sb.AppendLine();
            
                sb.AppendLine($"build build/{overlay}repl/{Path.GetFileNameWithoutExtension(file)}.bin: objcopy build/{overlay}repl/{Path.GetFileNameWithoutExtension(file)}.elf || build{dependency}");
                sb.AppendLine();
            }
        }
        
        return wroteMain;
    }
}