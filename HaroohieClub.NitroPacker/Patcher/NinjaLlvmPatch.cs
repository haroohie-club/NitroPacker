using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using HaroohieClub.NitroPacker.Patcher.Nitro;

namespace HaroohieClub.NitroPacker.Patcher;

/// <summary>
/// Static class for handling ASM patching via ninja/LLVM
/// </summary>
public static class NinjaLlvmPatch
{
    /// <summary>
    /// Patches ARM9 and overlays all at once using ninja and LLVM
    /// </summary>
    /// <param name="sourceDir">The path to the directory containing ASM hacks</param>
    /// <param name="arm9">The ARM9 binary to patch</param>
    /// <param name="overlayDir">The directory containing the game's overlay files to be patched</param>
    /// <param name="ninjaPath">The path to the ninja executable</param>
    /// <param name="llvmPath">The path to the LLVM root directory</param>
    /// <param name="romProjFile">The path to the ROM project file generated by NitroPacker's unpacking function</param>
    /// <param name="arenaLoOffset">The ArenaLo offset of the ROM (can be determined as described in the documentation)</param>
    /// <param name="symTableHelperPath">The path to the SymTableHelper executable (defaults to looking in the current directory)</param>
    /// <param name="outputDataReceived">A handler for standard output from ninja</param>
    /// <param name="errorDataReceived">A handler for standard error from ninja</param>
    public static void Patch(string sourceDir, ARM9 arm9, string overlayDir, string ninjaPath, string llvmPath,
        string romProjFile, uint arenaLoOffset, string symTableHelperPath = "", DataReceivedEventHandler outputDataReceived = null,
        DataReceivedEventHandler errorDataReceived = null)
    {
        GenerateNinjaBuildFile(sourceDir, llvmPath, symTableHelperPath, romProjFile, arenaLoOffset);
    }
    
    private static void GenerateNinjaBuildFile(string sourceDir, string llvmPath, string symTableHelperPath, string romProjFile, uint arenaLoOffset)
    {
        string exeExt = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? ".exe" : string.Empty;
        StringBuilder sb = new();
        sb.AppendLine("# File generated by NitroPacker");
        sb.AppendLine();
        
        sb.AppendLine($"LLVM             = {llvmPath}/bin/");
        sb.AppendLine($"CLANG            = ${{LLVM}}clang{exeExt}");
        sb.AppendLine($"LLD              = ${{LLVM}}ld.lld{exeExt}");
        sb.AppendLine($"OBJCOPY          = ${{LLVM}}llvm-objcopy{exeExt}");
        sb.AppendLine($"OBJDUMP          = ${{LLVM}}llvm-objdump{exeExt}");
        sb.AppendLine($"SYMTABLEHELPER   = {(string.IsNullOrEmpty(symTableHelperPath) ? 
            $"{Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location)}/NitroPacker.SymTableHelper{exeExt}" :
            symTableHelperPath)}");
        sb.AppendLine();
        
        sb.AppendLine("rule makedir");
        sb.AppendLine("  command = mkdir $out");
        sb.AppendLine();
        
        sb.AppendLine("rule cc");
        sb.AppendLine("  command = ${CLANG} -target armv5-none-eabi -g -march=armv5te -mtune=arm946e-s -nodefaultlibs -c -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule ld");
        sb.AppendLine("  command = ${LLD} -T ./linker.x -T ./symbols.x -Ttext ${codeaddr} ${ldflags} -g -o $out $in");
        sb.AppendLine();

        sb.AppendLine("rule objcopy");
        sb.AppendLine("  command = ${OBJCOPY} -O binary $in $out");
        sb.AppendLine();

        sb.AppendLine("rule objdump");
        sb.AppendLine("  command = ${OBJDUMP} -t $in > $out");
        sb.AppendLine();

        sb.AppendLine("rule symtablehelper");
        sb.AppendLine("  command = ${SYMTABLEHELPER} $in $out");
        sb.AppendLine();

        sb.AppendLine("build build: makedir");
        sb.AppendLine();

        bool wroteMain = AppendNinjaBuildCommands(sb, sourceDir, sourceDir, arenaLoOffset);
        
        NdsProjectFile proj = NdsProjectFile.Deserialize(romProjFile);
        foreach (string overlayDir in Directory.GetDirectories(Path.Combine(sourceDir, "overlays")))
        {
            string overlayName = Path.GetFileNameWithoutExtension(overlayDir);
            AppendNinjaBuildCommands(sb, sourceDir, overlayDir,
                proj.RomInfo.ARM9Ovt.First(o => o.Id == uint.Parse(overlayName[^4..])).RamAddress, $"{overlayName}/",
                wroteMain ? " build/newcode.x" : "");
        }
        
        File.WriteAllText(Path.Combine(sourceDir, "build.ninja"), sb.ToString());
    }

    private static bool AppendNinjaBuildCommands(StringBuilder sb, string sourceRoot, string sourceDir, uint codeAddress, string overlay = "", string dependency = "")
    {
        bool wroteMain = false;
        
        string mainSource = Path.Combine(sourceDir, "source");
        if (Directory.Exists(mainSource))
        {
            List<string> objFiles = [];
            foreach (string file in Directory.GetFiles(mainSource).Where(f =>
                         Path.GetExtension(f).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                         Path.GetExtension(f).Equals(".s", StringComparison.OrdinalIgnoreCase)))
            {
                string objFile = $"build/{overlay}{Path.GetFileName(file)}.o";
                objFiles.Add(objFile);
                sb.AppendLine($"build {objFile}: cc {mainSource.Replace(sourceRoot, "").Replace('\\', '/')}/{Path.GetFileName(file)} || build{dependency}");
                sb.AppendLine();
            }

            sb.Append($"build build/{overlay}newcode.elf: ld ");
            sb.AppendJoin(' ', objFiles);
            sb.AppendLine($" || build{dependency}");
            sb.AppendLine($"  codeaddr = {codeAddress:X8}");
            sb.AppendLine($"  ldflags = {(string.IsNullOrEmpty(overlay) ? "" : "-Map build/newcode.x")}");
            sb.AppendLine();
        
            sb.AppendLine($"build build/{overlay}newcode.bin: objcopy build/{overlay}newcode.elf || build{dependency}");
            sb.AppendLine();
        
            sb.AppendLine($"build build/{overlay}newcode.sym: objdump build/{overlay}newcode.elf || build{dependency}");
            sb.AppendLine();

            sb.AppendLine($"build build/{overlay}newcode.x: symtablehelper build/{overlay}newcode.sym || build{dependency}");
            sb.AppendLine();

            wroteMain = true;
            dependency += $" build/{overlay}newcode.x";
        }

        string replSource = Path.Combine(sourceDir, "replSource");
        if (Directory.Exists(replSource))
        {
            foreach (string file in Directory.GetFiles(replSource).Where(f =>
                         Path.GetExtension(f).Equals(".c", StringComparison.OrdinalIgnoreCase) ||
                         Path.GetExtension(f).Equals(".s", StringComparison.OrdinalIgnoreCase)))
            {
                sb.AppendLine($"build build/{overlay}{Path.GetFileName(file)}.o: cc {replSource.Replace(sourceRoot, "").Replace('\\', '/')}/{Path.GetFileName(file)} || build{dependency}");
                sb.AppendLine();

                sb.AppendLine($"build build/{overlay}{Path.GetFileNameWithoutExtension(file)}.elf: ld build/{overlay}{Path.GetFileName(file)}.o || build{dependency}");
                sb.AppendLine($"  codeaddr = {Path.GetFileNameWithoutExtension(file)}");
                sb.AppendLine($"  ldflags = {(string.IsNullOrEmpty(overlay) ? "" : "-Map build/newcode.x ")}-Map build/{overlay}newcode.x");
                sb.AppendLine();
            
                sb.AppendLine($"build build/{overlay}{Path.GetFileNameWithoutExtension(file)}.bin: objcopy build/{overlay}{Path.GetFileNameWithoutExtension(file)}.elf || build{dependency}");
                sb.AppendLine();
            }
        }
        
        return wroteMain;
    }
}